# 代码规范
![[变量命名与初始化规范.png]]

# 输入溢出问题
## 引入
过量的输入与不正确的写入字节会导致对内存位置的非预期变化,从而造成程序问题
## 过量的输入
在如下代码里我们对输入无限制,但buf的内存空间限制为20字节,如果我们输入超过20字节就会造成内存攻击
``` c title:输入不做限制
	char szbuf[20] = { 0 };
	printf("%p\r\n", szbuf);
	scanf("%s", szbuf);
```
![[C2_原空间.png]]
``` c title:输入内容
123451234512345123450000
//上述超过20个字符的溢出部分000 会修改后面的字符为0的Ascii码的码值30
```
![[C2_填充空间.png]]
### 解决办法
``` c title:限制输入长度
	char szbuf[20] = { 0 };
	printf("%p\r\n", szbuf);
	scanf("%19s", szbuf);
	//留一个字节放零
```

## 不正确的写入字节
int类型的写入是4字节但shor一个空间是2字节导致过量写入
``` c title:不正确的写入字节
	short int ary[2] = {666,999};
	scanf("%d", ary);
	
```
### 解决办法
限制写入的格式为short int 写入
``` c title:不正确的写入字节
	short int ary[2] = {666,999};
	scanf("%hd", ary);
```
# 内存占用
在程序中在不使用内存对齐的情况下,我们的使用字节以4字节为基础,任何操作会对齐到4的倍数,即便是char这种单字节类型
``` c title:char空间占用演示
char c1= 'a';
sizeof(c1);//1
//实际使用为4,下一个变量会在四字节地址之后
```


> 加减乘除与逻辑运算和位运算出来的是常量 ,所以不能做任何++或赋值的常量操作

# 精度转换
1. 明确转换,而不是隐式转换
2. int转float因为数据位问题还是会造成大数的数据丢失
