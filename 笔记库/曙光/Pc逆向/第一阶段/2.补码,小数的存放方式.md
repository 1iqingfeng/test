# 补码是什么 #补码
补码是一种编码方式,他约定了读写双方的方式,其中规定了三个基本规则
1. 一个字节里存在最高位为符号位,其余位置为数据位
2. 正数最高位为0,其余按照约定写入
3. 负数最高位为1,其余按照[[2.补码,小数的存放方式#求补运算|求补运算]]方式写入
## 小技巧
1. 16进制最高位大于等于8是负小于8是正
2. 运算负数前判断数据是正数还是负数,如果是负数**数据位取反加一读取**
3. 进位后的值都为零
## 课堂截图
![[补码与小数.png]]
# 求补运算 #求补运算
求补运算是对数据位取反加一符号位不变,因为计算机天生只会位运算和加法,通过求补运算解决了计算机的减法问题同时也解决了负数的存储问题
## 关键总结
1. 求补运算是对数据位取反加一符号位不变
2. 求补运算解决了计算机的负数存储问题
3. 求补运算解决了计算机的减法问题
# 二进制里的小数 #小数 #二进制 #二进制存储
## 引入
我们要知道二进制存储小数因为其数学模型缺陷有部分小数在其中无法达到数学意义的表达
### 判断二进制的精度
使用目标函数减去数学答案小于规定小数位的0.01就视为精度合格
``` c title:判断二进制的精度
	//伪代码实现判断funa的返回值在精度小数点后六位上属不属于1.8
	funa(A)-1.8<=0.000001&& funa(A) - 1.8 >= -0.000001
```
## 小数的二进制转换 #二进制转换 #小数 #二进制
## 引入
小数的存储问题分为定点数(常见与单片机)与浮点数(常见与小型机与微型机),但他们采用的转换算法都是相同的详情看[[2.补码,小数的存放方式#小数转二进制|小数转二进制]]
> 小数二进制位不足低位补零,整数二进制位不足高位补零

## 小数转二进制 #二进制转换 #小数
小数的二进制算法是去掉整数位拿小数位整体乘二取整数位结果,为一就取一舍去整数位,为零就取零直到小数位为零(不考虑特殊小数的情况下)
``` C title:小数算法示例
3.625
//3直接转尾二进制0011
1:3 ->0011
2:0.625*2 = 1.25 //取1
3:0.25*2 = 0.5//取0
4:0.5*2=1.0//取1
5:0011.101
```


> [!NOTE]  小数存放内存注意点
> 我们在存储小数的时候把小数点移动到有最前面1的位置后舍去这个数去存储,在读取时应该加回这个1

## 定点小数 #小数
假设一个四字节数据 我们在 高两位放整数,低两位放小数,这种无法考虑小数极多或者整数极多的小数存储方案我们称之为定点数
## 浮点小数 #小数 #浮点数
### 浮点小数转二进制
#### float #float
符号位1位 指数位8位 数据位23位
**其中指数位相加基数为127 ,小于127是纯小数**
``` c title:float换算过程
"s eeeeeeee ddddddddddd"
1:3.625
//过程参考小数算法示例
2:0011.101
//向前移动到只有一个一在前面
3:1.101
//移动了一位,换算二进制
//"s eeeeeeee ddddddddddd"
//127+1=129=10000000
4:0 10000000 1101 = 0100 0000 0110 1000 = 40680000
//4068转为小尾端,低位补零到四字节
5:00 00 68 40
```
#### double #double
符号位1位 指数位11位 数据位52位 
**其中指数位相加基数为1023,小于1023是纯小数**
``` c title:double换算过程
"s eeeeeeee ddddddddddd"
1:3.625
//过程参考小数算法示例
2:0011.101
//向前移动到只有一个一在前面
3:1.101
//移动了一位,换算二进制
//"s eeeeeeee ddddddddddd"
//1023+1=129=10000000
4:0 10000000000 1101 = 0100 0000 0000 1101 = 400D0000
//400D转为小尾端,低位补零到八字节
5:00 00 00 00 00 00 0D 40
```
### 浮点二进制转小数 #二进制转换 
二进制的小数算法是读取小数二进制的符号位与指数位,加一后还原数据位
``` c title:float换算过程
// 目标内存16进制直接转出2进制
1:0100 0000 0110 1000
//取出符号位与指数位
"s eeeeeeeeeee ddddddddddd"
2:0  10000000 01101000
//换算指数位
3:10000000 -> 128 -> 128-127 = 1
//得出指数位结果平移1位后小数点前加回一
//去除无用的零
4:11.101
//转结果
5:3.625
```
``` c title:double换算过程
// 目标内存16进制直接转出2进制
1:0100 0000 0000 1101
//取出符号位与指数位
"s eeeeeeeeeee ddddddddddd"
2:0 1000000000 1101
//换算指数位
3:10000000000 -> 1024 -> 1024-1023 = 1
//得出指数位结果平移1位后小数点前加回一
//去除无用的零
4:11.101
//转结果
5:3.625
```

# 待补充
怎么换算0.101到十进制